/* Neft object */
this._neft = {}

/* Global object */
this.global = this
this.window = this
this.self = this;

/* Console */
(function () {
  const valueToString = function (value) {
    var result
    if (typeof value === 'object' && value !== null && !(value instanceof RegExp)) {
      try {
        result = JSON.stringify(value)
      } catch (_error) {}
    }
    return result || String(value)
  }

  const inspect = function (args) {
    const strings = Array.prototype.map.call(args, valueToString)
    return Array.prototype.join.call(strings, ' ');
  }

  const getMesage = function(type, args) {
  	return '[' + type.toUpperCase() + '] ' + inspect(args)
  }

  const override = function(name) {
  	const superFunc = console[name]
  	console[name] = function() {
  		ios.log(getMesage(name, arguments))
  		superFunc.apply(console, arguments)
  	}
  }

  override('log')
  override('info')
  override('warn')
  override('error')
})();

/* Timeout Timer */
var setTimeout
var clearTimeout
(function () {
  const shots = Object.create(null)

  ios.timerCallback = function (id) {
  	const timer = shots[id]
    if (timer) {
      delete shots[id]
      timer()
    }
  }

  setTimeout = function (func, delay, arg1, arg2, arg3) {
    if (typeof func !== 'function') {
      throw new TypeError('callback argument must be a function')
    }

    if (typeof delay !== 'number') {
      delay = parseInt(delay, 10)
    }
    if (isNaN(delay)) {
      delay = 4
    }

    const argc = arguments.length
    var callFunc
    switch (argc) {
      case 1:
      case 2:
        callFunc = func
        break
      case 3:
        callFunc = function () {
          func(arg1)
        }
        break
      case 4:
        callFunc = function () {
          func(arg1, arg2)
        }
        break
      case 5:
        callFunc = function () {
          func(arg1, arg2, arg3)
        }
        break
      default:
        const args = new Array(argc - 2)
        for (var i = 2; i < argc; i += 1) {
          args[i - 2] = arguments[i]
        }
        callFunc = function () {
          func.apply(this, args)
        }
    }

    const id = ios.timerShot(delay)
    shots[id] = callFunc
    return id
  }

  clearTimeout = function (id) {
    delete shots[id]
  }
})();

/* Interval Timer */
var setInterval
var clearInterval
(function () {
  let lastId = 0
  const timers = Object.create(null)

  setInterval = function (func) {
    const intervalArguments = Array.prototype.slice.call(arguments)
    const id = lastId
    lastId += 1

    intervalArguments[0] = function(callArgs) {
      timers[id] = setTimeout.apply(this, intervalArguments)
      func.apply(this, callArgs)
    }

    timers[id] = setTimeout.apply(this, intervalArguments)

    return id
  }

  clearInterval = function (id) {
    clearTimeout(timers[id])
    delete timers[id]
  }
})();

/* setImmediate */
const setImmediate = function (func, arg1, arg2, arg3) {
  if (typeof func !== 'function') {
    throw new TypeError("callback argument must be a function")
  }
  const argc = arguments.length
  var callFunc
  switch (argc) {
    case 1:
      callFunc = func
      break
    case 2:
      callFunc = function() {
        func(arg1)
      }
      break
    case 3:
      callFunc = function() {
        func(arg1, arg2)
      }
      break
    case 4:
      callFunc = function() {
        func(arg1, arg2, arg3)
      }
      break
    default:
      const args = new Array(argc - 1)
      for (var i = 1; i < argc; i += 1) {
        args[i - 1] = arguments[i]
      }
      callFunc = function() {
        func.apply(this, args)
      }
  }
  ios.immediate(callFunc)
  return -1
};

/* requestAnimationFrame */
const requestAnimationFrame = (function () {
	const queue = []

	ios.animationFrameCallback = function () {
		for (var i = 0, n = queue.length; i < n; i += 1) {
			queue.shift()()
		}
	}

	return function(callback) {
		if (typeof callback === 'function') queue.push(callback)
	}
})();

/* Application code */
{{&bundle}}
